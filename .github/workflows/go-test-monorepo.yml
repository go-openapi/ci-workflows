name: go test [monorepo]

permissions:
  contents: read
  pull-requests: read

on:
  workflow_call:
    inputs:
      extra-flags:
        description: extra flags to add to go test
        type: string
        required: false

defaults:
  run:
    shell: bash

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    outputs:
      is-monorepo: ${{ steps.detect-monorepo.outputs.is-monorepo }}
      bash-paths: ${{ steps.detect-monorepo.outputs.bash-paths }}
      bash-subpaths: ${{ steps.detect-monorepo.outputs.bash-subpaths }}
      module-names: ${{ steps.detect-monorepo.outputs.names }}
      coverpkg: ${{ steps.prepare-tests.outputs.coverpkg }}
      all-modules: ${{ steps.prepare-tests.outputs.all-modules }}
    steps:
      -
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0
      -
        uses: actions/setup-go@4b73464bb391d4059bd26b0524d20df3927bd417 # v6.3.0
        with:
          go-version: stable
          check-latest: true
          cache: true
          cache-dependency-path: '**/go.sum'
      -
        name: Detect go mono-repo
        id: detect-monorepo
        uses: go-openapi/gh-actions/ci-jobs/detect-go-monorepo@23cdaeff454807ac293a6e98cff552a2ea49be63 # v1.4.7
      -
        name: golangci-lint [monorepo]
        # golangci-action v9.1+ has an experimental built-in mono repo detection setup.
        if: ${{ steps.detect-monorepo.outputs.is-monorepo == 'true' }}
        uses: golangci/golangci-lint-action@1e7e51e771db61008b38414a730f564565cf7c20 # v9.2.0
        with:
          version: latest
          only-new-issues: true
          skip-cache: true
          experimental: "automatic-module-directories"
      -
        name: golangci-lint
        if: ${{ steps.detect-monorepo.outputs.is-monorepo != 'true' }}
        uses: golangci/golangci-lint-action@1e7e51e771db61008b38414a730f564565cf7c20 # v9.2.0
        with:
          version: latest
          only-new-issues: true
          skip-cache: true
      -
        name: Prepare tests
        id: prepare-tests
        run: |
          coverpkg=$(echo '${{ steps.detect-monorepo.outputs.names }}' | jq -rc  '.[]|.+"/..."'|tr '\n' ','|head -c -1)
          echo "coverpkg=${coverpkg}" >> "${GITHUB_OUTPUT}"
          echo "::notice::title=coverpkg::${coverpkg}"

          declare -a ALL_MODULES
          ALL_MODULES=(${{ steps.detect-monorepo.outputs.bash-subpaths }}) # a bash array with all module folders, suffixed with "/..."
          echo "all-modules=${ALL_MODULES[@]}" >> "${GITHUB_OUTPUT}"
          echo "::notice::title=Modules found::${ALL_MODULES[@]}"

      # Carry out the linting the traditional way, within a shell loop
      #-
      #  name: Lint multiple modules
      #  if: ${{ steps.detect-monorepo.outputs.is-monorepo == 'true' }}
      #  # golangci-lint doesn't support go.work to lint multiple modules in one single pass
      #  run: |
      #    set -euxo pipefail
      #    git fetch origin master
      #    git show --no-patch --oneline origin/master
      #    while read -r module_location ; do
      #      pushd "${module_location}"
      #      golangci-lint run --new-from-rev origin/master
      #      popd
      #    done < <(echo ${{ steps.detect-monorepo.outputs.bash-paths }})

  test:
    name: Unit tests mono-repo
    needs: [ lint ]
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ ubuntu-latest, macos-latest, windows-latest ]
        go: ['oldstable', 'stable' ]
    steps:
      -
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      -
        uses: actions/setup-go@4b73464bb391d4059bd26b0524d20df3927bd417 # v6.3.0
        id: go-setup
        with:
          go-version: '${{ matrix.go }}'
          check-latest: true
          cache: true
          cache-dependency-path: '**/go.sum'
      -
        name: Detect go version capabilities
        id: detect-go-version
        uses: go-openapi/gh-actions/ci-jobs/detect-go-version@23cdaeff454807ac293a6e98cff552a2ea49be63 # v1.4.7
      -
        name: Install gotestsum
        uses: go-openapi/gh-actions/install/gotestsum@23cdaeff454807ac293a6e98cff552a2ea49be63 # v1.4.7
      -
        name: Ensure TMP is created on windows runners
        # On windows, some tests require testing.TempDir to reside on the same drive as the code.
        # TMP is used by os.TempDir() to determine the location of temporary files.
        # This is in particular the case for all programs that use [filepath.Rel].
        if: ${{ runner.os  == 'Windows' }}
        shell: bash
        run: |
          TMP="${{ github.workspace }}\..\tmp"
          mkdir -p ${TMP}
          echo "TMP=${TMP}" >> "${GITHUB_ENV}"
      -
        name: Run unit tests on all modules (go1.25+ with go.work) [monorepo]
        if: ${{ needs.lint.outputs.is-monorepo == 'true' && steps.detect-go-version.outputs.is-gotestwork-supported == 'true' }}
        # with go.work file enabled, go test recognizes sub-modules and collects all packages to be covered
        # without specifying -coverpkg.
        #
        # However, cross-module test coverage is only reported with the appropriate -coverpkg setting.
        #
        # This requires:
        # * go.work properly initialized with use of all known modules
        # * go.work committed to git
        env:
          EXTRA_FLAGS: ${{ inputs.extra-flags }}
        run: >

          gotestsum
          --jsonfile 'unit.report.${{ matrix.os }}-${{ matrix.go }}.json'
          --
          work
          -race
          -p 2
          -count 1
          -timeout=20m
          -coverprofile='unit.coverage.${{ matrix.os }}-${{ matrix.go }}.out'
          -covermode=atomic
          -coverpkg='${{ needs.lint.outputs.coverpkg }}' ${EXTRA_FLAGS}
          ./...
      - 
        name: Run unit tests on all modules (<go1.25 or no go.work) [monorepo]
        if: >
          ${{
              needs.lint.outputs.is-monorepo == 'true' && steps.detect-go-version.outputs.is-gotestwork-supported != 'true'
          }}
        env:
          EXTRA_FLAGS: ${{ inputs.extra-flags }}
          ALL_MODULES: ${{ needs.lint.outputs.all-modules }}
        run: >
          gotestsum
          --jsonfile 'unit.report.${{ matrix.os }}-${{ matrix.go }}.json'
          --
          -race
          -p 2
          -count 1
          -timeout=20m
          -coverprofile='unit.coverage.${{ matrix.os }}-${{ matrix.go }}.out'
          -covermode=atomic
          -coverpkg='${{ needs.lint.outputs.coverpkg }}' ${EXTRA_FLAGS}
          ${ALL_MODULES}
      -
        name: Run unit tests
        if: ${{ needs.lint.outputs.is-monorepo != 'true' }}
        env:
          EXTRA_FLAGS: ${{ inputs.extra-flags }}
        run: >
          gotestsum
          --jsonfile 'unit.report.${{ matrix.os }}-${{ matrix.go }}.json'
          --
          -race
          -p 2
          -count 1
          -timeout=20m
          -coverprofile='unit.coverage.${{ matrix.os }}-${{ matrix.go }}.out'
          -covermode=atomic
          -coverpkg="$(go list)"/... ${EXTRA_FLAGS}
          ./...
      -
        name: Upload coverage artifacts
        uses: actions/upload-artifact@bbbca2ddaa5d8feaa63e36b76fdaad77386f024f # v7.0.0
        with:
          # *.coverage.* pattern is automatically detected by codecov
          path: '**/*.coverage.*.out'
          name: 'unit.coverage.${{ matrix.os }}-${{ matrix.go }}'
          retention-days: 1
      -
        name: Upload test report artifacts
        # upload report even if tests fail. BTW, this is when they are valuable.
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@bbbca2ddaa5d8feaa63e36b76fdaad77386f024f # v7.0.0
        with:
          path: '**/unit.report.*.json'
          name: 'unit.report.${{ matrix.os }}-${{ matrix.go }}'
          retention-days: 1

  fuzz-test:
    # fuzz-test supports go monorepos
    uses: ./.github/workflows/fuzz-test.yml

  test-complete:
    # description: |
    #   Be explicit about all tests being passed. This allows for setting up only a few status checks on PRs.
    name: tests completed
    needs: [test,fuzz-test]
    runs-on: ubuntu-latest
    steps:
      -
        name: Tests completed
        run: |
          echo "::notice title=Success::All tests passed"

  collect-coverage:
    needs: [test-complete]
    if: ${{ !cancelled() && needs.test-complete.result == 'success' }}
    uses: ./.github/workflows/collect-coverage.yml

  collect-reports:
    needs: [test]
    if: ${{ !cancelled() }}
    uses: ./.github/workflows/collect-reports.yml
