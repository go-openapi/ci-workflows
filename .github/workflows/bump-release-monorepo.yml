name: Bump Release [monorepo]

permissions:
  contents: read

# description: |
#   Manual action to bump the current version and cut a release for mono-repo projects.
#
#   Determine which version to bump.
#   Generate release notes for each module.
#   Tag all modules with the new version.
#   Build a github release on pushed tag.

defaults:
  run:
    shell: bash

on:
  workflow_call:
    inputs:
      bump-type:
        description: Type of bump (patch, minor, major)
        type: string
        default: patch
        required: false
      tag-message-title:
        description: Tag message title to prepend to the release notes
        required: false
        type: string
      tag-message-body:
        description: |
          Tag message body to prepend to the release notes.
          (use "|" to replace end of line).
        required: false
        type: string
      enable-tag-signing:
        description: |
          Enable PGP tag-signing by a bot user.

          When enabled, you must pass the GPG secrets to this workflow.
        required: false
        type: string
        default: 'true'
      enable-commit-signing:
        description: |
          Enable PGP commit-signing by a bot user (for mono-repo releases).

          When enabled, you must pass the GPG secrets to this workflow.
        required: false
        type: string
        default: 'true'
      cliff-config:
        type: string
        required: false
        default: '.cliff.toml'
        description: 'Path to the git-cliff config file in the caller repository'
      cliff-config-url:
        type: string
        required: false
        default: 'https://raw.githubusercontent.com/go-openapi/ci-workflows/refs/heads/master/.cliff.toml'
        description: 'URL to the remote git-cliff config file (used if local config does not exist)'
      monorepo-cliff-template:
        type: string
        required: false
        default: '.cliff-monorepo.toml'
        description: 'Path to the git-cliff template used to generate module-specific release notes'
      monorepo-cliff-template-url:
        type: string
        required: false
        default: https://raw.githubusercontent.com/go-openapi/ci-workflows/refs/heads/master/.cliff-monorepo.toml
        description: 'URL to the remote git-cliff template used to generate module-specific release notes'
    secrets:
      gpg-private-key:
        description: |
          GPG private key in armored format for signing tags.

          Default for go-openapi: CI_BOT_GPG_PRIVATE_KEY

          Required when enable-tag-signing is true.
        required: false
      gpg-passphrase:
        description: |
          Passphrase to unlock the GPG private key.

          Default for go-openapi: CI_BOT_GPG_PASSPHRASE

          Required when enable-tag-signing is true.
        required: false
      gpg-fingerprint:
        description: |
          Fingerprint of the GPG signing key (spaces removed).

          Default for go-openapi: CI_BOT_SIGNING_KEY

          Required when enable-tag-signing is true.
        required: false
      github-app-id:
        description: |
          GitHub App ID for bot user authentication.

          Default for go-openapi: CI_BOT_APP_ID

          Required to create pull requests as the bot user.
        required: false
      github-app-private-key:
        description: |
          GitHub App private key in PEM format.

          Default for go-openapi: CI_BOT_APP_PRIVATE_KEY

          Required to create pull requests as the bot user.
        required: false

jobs:
  detect-modules:
    name: Detect mono-repo modules
    runs-on: ubuntu-latest
    outputs:
      is-monorepo: ${{ steps.detect-monorepo.outputs.is-monorepo }}
      names: ${{ steps.detect-monorepo.outputs.names }}
      bash-relative-names: ${{ steps.detect-monorepo.outputs.bash-relative-names }}
    steps:
      -
        name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0
      -
        name: Setup Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version: stable
          check-latest: true
          cache: true
          cache-dependency-path: '**/go.sum'
      -
        name: Detect go mono-repo
        id: detect-monorepo
        uses: go-openapi/gh-actions/ci-jobs/detect-go-monorepo@f94d1f200adab8d24b37584e5f61795a6062421d # v1.4.6

  bump-release-single:
    name: Bump release (single module)
    needs: [detect-modules]
    if: ${{ needs.detect-modules.outputs.is-monorepo != 'true' }}
    permissions:
      contents: write
    uses: ./.github/workflows/bump-release.yml
    with:
      bump-type: ${{ inputs.bump-type }}
      tag-message-title: ${{ inputs.tag-message-title }}
      tag-message-body: ${{ inputs.tag-message-body }}
      enable-tag-signing: ${{ inputs.enable-tag-signing }}
      cliff-config: ${{ inputs.cliff-config }}
      cliff-config-url: ${{ inputs.cliff-config-url }}
    secrets:
      gpg-private-key: ${{ secrets.gpg-private-key }}
      gpg-passphrase: ${{ secrets.gpg-passphrase }}
      gpg-fingerprint: ${{ secrets.gpg-fingerprint }}

  determine-next-tag:
    name: Determine next tag [monorepo]
    needs: [detect-modules]
    if: ${{ needs.detect-modules.outputs.is-monorepo == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      next-tag: ${{ steps.bump-release.outputs.next-tag }}
    steps:
      -
        name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0
      -
        name: Determine bump type
        id: bump-check
        run: |
          BUMP_TYPE="${{ inputs.bump-type }}"

          if [[ "${BUMP_TYPE}" == "patch" ]] ; then
            echo "bump-patch=true" >> "${GITHUB_OUTPUT}"
            echo "bump-minor=false" >> "${GITHUB_OUTPUT}"
            echo "bump-major=false" >> "${GITHUB_OUTPUT}"
          elif [[ "${BUMP_TYPE}" == "minor" ]] ; then
            echo "bump-patch=false" >> "${GITHUB_OUTPUT}"
            echo "bump-minor=true" >> "${GITHUB_OUTPUT}"
            echo "bump-major=false" >> "${GITHUB_OUTPUT}"
          elif [[ "${BUMP_TYPE}" == "major" ]] ; then
            echo "bump-patch=false" >> "${GITHUB_OUTPUT}"
            echo "bump-minor=false" >> "${GITHUB_OUTPUT}"
            echo "bump-major=true" >> "${GITHUB_OUTPUT}"
          else
            echo "::error::invalid parameter ${BUMP_TYPE}"
            exit 1
          fi
      -
        name: Determine next tag
        id: bump-release
        uses: go-openapi/gh-actions/ci-jobs/next-tag@f94d1f200adab8d24b37584e5f61795a6062421d # v1.4.6
        with:
          bump-patch: ${{ steps.bump-check.outputs.bump-patch }}
          bump-minor: ${{ steps.bump-check.outputs.bump-minor }}
          bump-major: ${{ steps.bump-check.outputs.bump-major }}

  prepare-modules:
    name: Prepare module updates [monorepo]
    needs: [detect-modules, determine-next-tag]
    if: ${{ needs.detect-modules.outputs.is-monorepo == 'true' }}
    permissions:
      contents: write
      pull-requests: write
    uses: ./.github/workflows/prepare-release-monorepo.yml
    with:
      target-tag: ${{ needs.determine-next-tag.outputs.next-tag }}
      enable-commit-signing: ${{ inputs.enable-commit-signing }}
    secrets:
      github-app-id: ${{ secrets.github-app-id }}
      github-app-private-key: ${{ secrets.github-app-private-key }}
      gpg-private-key: ${{ secrets.gpg-private-key }}
      gpg-passphrase: ${{ secrets.gpg-passphrase }}
      gpg-fingerprint: ${{ secrets.gpg-fingerprint }}

  wait-for-merge:
    name: Wait for PR merge [monorepo]
    needs: [detect-modules, prepare-modules]
    if: ${{ needs.detect-modules.outputs.is-monorepo == 'true' }}
    runs-on: ubuntu-latest
    env:
      PR_URL: ${{ needs.prepare-modules.outputs.pull-request-url }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      -
        name: Checkout repository
        if: ${{ needs.prepare-modules.outputs.pull-request-operation  != 'none' && needs.prepare-modules.outputs.pull-request-operation != 'closed' }}
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      -
        name: Wait for PR to be merged
        if: ${{ needs.prepare-modules.outputs.pull-request-operation  != 'none' && needs.prepare-modules.outputs.pull-request-operation != 'closed' }}
        run: |
          echo "::notice title=waiting-for-merge::Waiting for PR ${PR_URL} to be merged"

          MAX_WAIT=1800  # 30 minutes maximum wait time
          POLL_INTERVAL=30  # Check every 30 seconds
          elapsed=0

          while [ $elapsed -lt $MAX_WAIT ]; do
            # Check PR state
            PR_STATE=$(gh pr view "$PR_URL" --json state --jq '.state')

            if [[ "$PR_STATE" == "MERGED" ]]; then
              echo "::notice title=pr-merged::PR has been merged successfully"
              exit 0
            elif [[ "$PR_STATE" == "CLOSED" ]]; then
              echo "::error title=pr-closed::PR was closed without merging"
              exit 1
            fi

            echo "::notice title=polling::PR state: ${PR_STATE}, waiting... (${elapsed}s elapsed)"
            sleep $POLL_INTERVAL
            elapsed=$((elapsed + POLL_INTERVAL))
          done

          echo "::error title=timeout::Timed out waiting for PR to be merged after ${MAX_WAIT}s"
          exit 1
      -
        name: Report status
        run: |
          if [ -z "${PR_URL}" ] ; then
            echo "::notice title=waiting-for-merge::No PR to be waited for. Proceed."
          else
            echo "::notice title=waiting-for-merge::Waiting for PR ${PR_URL} to be merged"
          fi

          if [[ "${{ needs.prepare-modules.outputs.pull-request-operation }}" == "none" ]] ; then
            echo "::notice title=wait-for-pr::no pull request expected. Skipped waiting."
          elif [[ "${{ needs.prepare-modules.outputs.pull-request-operation }}" == "closed" ]] ; then
            echo "::notice title=wait-for-pr::pull request closed, assumed merged. Skipped waiting."
          else
            echo "::notice title=wait-for-pr::pull request merged. Can proceed with the tagging and release"
          fi

  tag-release-monorepo:
    name: Tag release [mono-repo]
    needs: [detect-modules, determine-next-tag, wait-for-merge]
    if: ${{ needs.detect-modules.outputs.is-monorepo == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      next-tag: ${{ needs.determine-next-tag.outputs.next-tag }}
      all-tags: ${{ steps.tag-modules.outputs.all-tags }}
    steps:
      -
        name: Checkout code (fresh after PR merge)
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0
          # Fetch the latest code after the PR has been merged
          ref: ${{ github.ref }}
      -
        name: Setup Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version: stable
          check-latest: true
          cache: true
          cache-dependency-path: '**/go.sum'
      -
        name: Configure bot credentials
        if: ${{ inputs.enable-tag-signing == 'true' }}
        uses: go-openapi/gh-actions/ci-jobs/bot-credentials@f94d1f200adab8d24b37584e5f61795a6062421d # v1.4.6
        # This is using the GPG signature of bot-go-openapi.
        #
        # For go-openapi repos (using secrets: inherit):
        #   Falls back to: CI_BOT_GPG_PRIVATE_KEY, CI_BOT_GPG_PASSPHRASE, CI_BOT_SIGNING_KEY
        #
        # For other orgs: explicitly pass secrets with your custom names
        # NOTE(fredbi): extracted w/ gpg -K --homedir gnupg --keyid-format LONG --with-keygrip --fingerprint --with-subkey-fingerprint
        with:
          enable-gpg-signing: 'true'
          gpg-private-key: ${{ secrets.gpg-private-key || secrets.CI_BOT_GPG_PRIVATE_KEY }}
          gpg-passphrase: ${{ secrets.gpg-passphrase || secrets.CI_BOT_GPG_PASSPHRASE }}
          gpg-fingerprint: ${{ secrets.gpg-fingerprint || secrets.CI_BOT_SIGNING_KEY }}
          enable-tag-signing: 'true'
          enable-commit-signing: 'false'
      -
        name: Tag all modules
        id: tag-modules
        env:
          NEXT_TAG: ${{ needs.determine-next-tag.outputs.next-tag }}
          MESSAGE_TITLE: ${{ inputs.tag-message-title }}
          MESSAGE_BODY: ${{ inputs.tag-message-body }}
          MODULE_RELATIVE_NAMES: ${{ needs.detect-modules.outputs.bash-relative-names }}
          GITHUB_REPO: ${{ github.repository }}
        run: |
          set -x

          # Tag all modules similar to hack/tag_modules.sh
          # Note: The PR with updated go.mod files has been merged at this point
          root="$(git rev-parse --show-toplevel)"
          declare -a all_tags

          cd "${root}"

          # Construct the tag message.
          # A blank line between title and body is required for git to
          # distinguish %(contents:subject) from %(contents:body).
          # Body lines use "|" as paragraph separator (workflow inputs
          # do not support multiline strings).
          MESSAGE="${MESSAGE_TITLE}"
          if [[ -n "${MESSAGE_BODY}" ]] ; then
            BODY=$(printf '%s' "${MESSAGE_BODY}" | sed 's/|/\n\n/g')
            MESSAGE=$(printf "%s\n\n%s\n" "${MESSAGE}" "${BODY}")
          fi

          echo "::notice title=tag-message::Tagging all modules for ${NEXT_TAG}"

          SIGNED=""
          if [[ '${{ inputs.enable-tag-signing }}' == 'true' ]] ; then
             SIGNED="-s"
          else
             # whenever not signed, we need a DCO
             git config --global user.name "bot-go-openapi"
             git config --global user.email "gogatekeeper-openapi@yahoo.com"
          fi

          # Tag all modules
          declare -a ALL_RELATIVE_MODULES
          mapfile -d' ' -t ALL_RELATIVE_MODULES < <(printf "%s" "${MODULE_RELATIVE_NAMES}")
          for module_relative_name in "${ALL_RELATIVE_MODULES[@]}"; do
            module_relative_name=$(echo ${module_relative_name#"github.com/${GITHUB_REPO}/"}|sed -E 's/\/v[0-9]+$//') # in some case, the module is not prefixed by the root module, e.g. "v2" modules.
            if [[ -z "${module_relative_name}" || "${module_relative_name}" == "{root}" ]] ; then
              module_tag="${NEXT_TAG}" # e.g. "v0.24.0"
            else
              module_tag="${module_relative_name}/${NEXT_TAG}" # e.g. "mangling/v0.24.0"
            fi

            all_tags+=("${module_tag}")
            echo "::notice title=tagging::Creating tag: ${module_tag}"

            git tag ${SIGNED} -m "${MESSAGE}" "${module_tag}"

            if [[ -n "${SIGNED}" ]] ; then
              git tag -v "${module_tag}"
            fi
          done

          # Save all tags for output
          echo "all-tags=${all_tags[@]}" >> "${GITHUB_OUTPUT}"

          # Push all tags to origin
          echo "::notice title=pushing-tags::Pushing tags: ${all_tags[@]}"
          git push origin ${all_tags[@]}

  gh-release-monorepo:
    # trigger release creation explicitly.
    #
    # The previous tagging action does not trigger the normal release workflow
    # (github prevents cascading triggers from happening).
    name: Create release [monorepo]
    needs: [detect-modules, tag-release-monorepo]
    if: ${{ needs.detect-modules.outputs.is-monorepo == 'true' }}
    permissions:
      contents: write
    uses: ./.github/workflows/release.yml
    with:
      tag: ${{ needs.tag-release-monorepo.outputs.next-tag }}
      is-monorepo: 'true'
      cliff-config: ${{ inputs.cliff-config }}
      cliff-config-url: ${{ inputs.cliff-config-url }}
      monorepo-cliff-template: ${{ inputs.monorepo-cliff-template }}
      monorepo-cliff-template-url: ${{ inputs.monorepo-cliff-template-url }}
    secrets: inherit
