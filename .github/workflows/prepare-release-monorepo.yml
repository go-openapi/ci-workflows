name: Prepare Release [monorepo]

permissions:
  contents: read

# description: |
#   Prepares a release for mono-repo projects by updating go.mod files.
#
#   This workflow:
#   1. Updates go.mod files in all modules to use the new version
#   2. Creates a bot PR with the changes
#   3. (Future) Waits for the PR to be merged before tagging
#
#   The PR will be auto-merged if all checks pass.

defaults:
  run:
    shell: bash

on:
  workflow_call:
    outputs:
      pull-request-url:
        description: "URL of the created pull request"
        value: ${{ jobs.prepare-modules.outputs.pull-request-url }}
    inputs:
      target-tag:
        description: |
          Target tag for the release (e.g., v0.24.0).

          This tag will be used to update inter-module dependencies, but not pushed to the repo yet.
        type: string
        required: true
      enable-commit-signing:
        description: |
          Enable GPG commit signing by a bot user.

          When enabled, commits in the pull request will be signed with the bot's GPG key.
        required: false
        type: string
        default: 'true'
    secrets:
      github-app-id:
        description: |
          GitHub App ID for bot user authentication.

          Default for go-openapi: CI_BOT_APP_ID

          Required to create pull requests as the bot user.
        required: false
      github-app-private-key:
        description: |
          GitHub App private key in PEM format.

          Default for go-openapi: CI_BOT_APP_PRIVATE_KEY

          Required to create pull requests as the bot user.
        required: false
      gpg-private-key:
        description: |
          GPG private key in armored format for signing commits.

          Default for go-openapi: CI_BOT_GPG_PRIVATE_KEY

          Required when enable-commit-signing is true.
        required: false
      gpg-passphrase:
        description: |
          Passphrase to unlock the GPG private key.

          Default for go-openapi: CI_BOT_GPG_PASSPHRASE

          Required when enable-commit-signing is true.
        required: false
      gpg-fingerprint:
        description: |
          Fingerprint of the GPG signing key (spaces removed).

          Default for go-openapi: CI_BOT_SIGNING_KEY

          Required when enable-commit-signing is true.
        required: false

jobs:
  prepare-modules:
    name: Prepare module updates
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    outputs:
      pull-request-url: ${{ steps.create-pull-request.outputs.pull-request-url }}
    steps:
      -
        name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
      -
        name: Setup Go
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6.1.0
        with:
          go-version: stable
          check-latest: true
          cache: true
          cache-dependency-path: '**/go.sum'
      -
        name: Detect go mono-repo
        id: detect-monorepo
        uses: go-openapi/gh-actions/ci-jobs/detect-go-monorepo@8340d5403ad368f2ddaa0bc3b10ce38a10099e2c # v1.4.3
      -
        name: Update go.mod files for new release
        env:
          TARGET_TAG: ${{ inputs.target-tag }}
          MODULE_PATHS: ${{ steps.detect-monorepo.outputs.bash-paths }}
        run: |
          set -x
          unset GOTOOLCHAIN

          # Update go.mod files in all modules to reference the new version
          root="$(git rev-parse --show-toplevel)"
          cd "${root}"

          # Infer the root module path (e.g., "github.com/go-openapi/swag")
          root_module="${{ steps.detect-monorepo.outputs.root-module }}"
          echo "::notice title=prepare-release::Updating modules to ${TARGET_TAG} for ${root_module}"

          # Find all go.mod directories and process them.
          #
          # Since all internal dependencies are already resolved using "replace" directives,
          # what we are adding here is only visible to external users of the package, not locally.
          #
          # Therefore, there is no need to care about the order in which we apply this change.
          declare -a ALL_FOLDERS
          mapfile -d' ' -t ALL_FOLDERS < <(printf "%s" "${MODULE_PATHS}")
          for dir in "${ALL_FOLDERS[@]}"; do
            echo "::notice title=processing-module::Processing module in ${dir}"
            pushd "${dir}" > /dev/null
            echo "Original go.mod"
            cat go.mod

            go mod download -x

            # List dependencies and update those matching the root module or sub-modules
            # This matches both the root module and any sub-modules under the same path.
            #
            # In some situations, we may have a test dependency of a module on itself and this
            # case must be skipped.
            current_module=$(go list)
            while read -r module ; do
              echo "::notice title=updating-dependency::Updating ${module} to ${TARGET_TAG}"
              go mod edit -require "${module}@${TARGET_TAG}"
            done < <( go list -deps -test \
              -f '{{ if .DepOnly }}{{ with .Module }}{{ .Path }}{{ end }}{{ end }}' | \
              sort -u | \
              grep "^${root_module}" | \
              grep -v "^${current_module}$" || true )
            echo "Transformed go.mod"
            cat go.mod

            # Tidy the go.mod file
            echo "::notice title=tidy::Running go mod tidy in ${dir}"
            go mod tidy -v

            popd > /dev/null
          done

          # Sync go.work if it exists
          if [[ -f go.work ]] ; then
            echo "::notice title=sync::Running go work sync"
            go work sync
          fi

          # Show what changed
          echo "::notice title=changes::Git status after updates"
          git status --short
      -
        name: Configure bot credentials
        uses: go-openapi/gh-actions/ci-jobs/bot-credentials@8340d5403ad368f2ddaa0bc3b10ce38a10099e2c # v1.4.3
        id: bot-credentials
        # For go-openapi repos (using secrets: inherit):
        #   Falls back to: CI_BOT_APP_ID, CI_BOT_APP_PRIVATE_KEY, CI_BOT_GPG_PRIVATE_KEY, etc.
        #
        # For other orgs: explicitly pass secrets with your custom names
        with:
          enable-github-app: 'true'
          github-app-id: ${{ secrets.github-app-id || secrets.CI_BOT_APP_ID }}
          github-app-private-key: ${{ secrets.github-app-private-key || secrets.CI_BOT_APP_PRIVATE_KEY }}
          enable-gpg-signing: ${{ inputs.enable-commit-signing }}
          gpg-private-key: ${{ secrets.gpg-private-key || secrets.CI_BOT_GPG_PRIVATE_KEY }}
          gpg-passphrase: ${{ secrets.gpg-passphrase || secrets.CI_BOT_GPG_PASSPHRASE }}
          gpg-fingerprint: ${{ secrets.gpg-fingerprint || secrets.CI_BOT_SIGNING_KEY }}
          enable-commit-signing: 'true'
          enable-tag-signing: 'false'
      -
        name: Create pull request
        id: create-pull-request
        uses: peter-evans/create-pull-request@98357b18bf14b5342f975ff684046ec3b2a07725 # v8.0.0
        env:
          TARGET_TAG: ${{ inputs.target-tag }}
        with:
          commit-message: "chore: prepare release ${{ inputs.target-tag }}"
          branch: release/prepare-${{ inputs.target-tag }}
          delete-branch: true
          title: "chore: prepare release ${{ inputs.target-tag }}"
          body: |
            This PR prepares the mono-repo for release `${{ inputs.target-tag }}`.

            **Changes:**
            - Updated inter-module dependencies to `${{ inputs.target-tag }}`
            - Ran `go mod tidy` on all modules
            - Synced `go.work` (if present)

            This PR will be auto-merged once all checks pass.
          token: ${{ steps.bot-credentials.outputs.app-token }}
          labels: "bot,release"
          draft: false
          sign-commits: ${{ inputs.enable-commit-signing }}
          signoff: true # DCO

  auto-merge:
    # description: |
    #   Approves the PR, waits for all jobs (including non-required ones), and enables auto-merge.
    #
    #   This workflow completes the full auto-merge flow for bot-created PRs:
    #   1. Approve the PR (bot can't approve its own PR)
    #   2. Wait for all workflow runs to complete (prevents branch deletion during non-required jobs)
    #   3. Enable auto-merge if not already enabled (avoids race condition with auto-merge.yml)
    #
    #   Future enhancement: Wait for the PR to be merged before proceeding to tag the release.
    #   Note: The merge may be completed by this workflow or by auto-merge.yml running in parallel.
    needs: [prepare-modules]
    permissions:
      contents: write
      pull-requests: write
    runs-on: ubuntu-latest
    env:
      PR_URL: ${{ needs.prepare-modules.outputs.pull-request-url }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      -
        name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
      -
        name: Auto-approve PR
        run: gh pr review --approve "$PR_URL"
      -
        name: Wait for all workflow runs to complete
        uses: go-openapi/gh-actions/ci-jobs/wait-pending-jobs@8340d5403ad368f2ddaa0bc3b10ce38a10099e2c # v1.4.3
        with:
          pr-url: ${{ env.PR_URL }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
      -
        name: Enable auto-merge
        run: |
          # Attempt to enable auto-merge, handling race condition gracefully
          set +e  # Don't exit on error
          OUTPUT=$(gh pr merge --auto --rebase "$PR_URL" 2>&1)
          EXIT_CODE=$?
          set -e  # Re-enable exit on error

          if [ $EXIT_CODE -eq 0 ]; then
            echo "::notice title=auto-merge::Auto-merge enabled successfully"
            exit 0
          fi

          # Check if error is due to race condition (merge already in progress)
          # GitHub GraphQL API returns: "GraphQL: Merge already in progress (mergePullRequest)"
          if echo "$OUTPUT" | grep -q "Merge already in progress"; then
            echo "::warning title=auto-merge::Auto-merge already handled by another workflow (race condition)"
            exit 0
          fi

          # Unexpected error - fail the workflow
          echo "::error title=auto-merge::Failed to enable auto-merge"
          echo "$OUTPUT"
          exit $EXIT_CODE
