name: Release

permissions:
  contents: read

# description: |
#   Build a github release on either pushed tag or a manual workflow call.
#
#   At this moment, the only available asset is a release note.

on:
  workflow_call:
    inputs:
      tag:
        type: string
        required: true
      is-monorepo:
        type: string
        required: false
        default: 'false'
        description: 'Set to true for mono-repo projects to generate per-module release notes'
      cliff-config:
        type: string
        required: false
        default: '.cliff.toml'
        description: 'Path to the git-cliff config file in the caller repository'
      cliff-config-url:
        type: string
        required: false
        default: 'https://raw.githubusercontent.com/go-openapi/ci-workflows/refs/heads/master/.cliff.toml'
        description: 'URL to the remote git-cliff config file (used if local config does not exist)'
      monorepo-cliff-template:
        type: string
        required: false
        default: '.cliff-monorepo.toml'
        description: 'Path to the git-cliff template used to generate module-specific release notes'
      monorepo-cliff-template-url:
        type: string
        required: false
        default: https://raw.githubusercontent.com/go-openapi/ci-workflows/refs/heads/master/.cliff-monorepo.toml
        description: 'URL to the remote git-cliff template used to generate module-specific release notes'

jobs:
  gh-release:
    name: Create release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      -
        name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0
          ref: ${{ inputs.tag }}
          fetch-tags: true
      -
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version: stable
          check-latest: true
          cache: true
          cache-dependency-path: '**/go.sum'
      -
        name: Extract tag message
        id: get-message
        # The tag message is not retrieved unless we fetch the ref explicitly.
        # This step actually only requires depth=1, but subsequent steps consume the full history.
        # We ensure that we get a complete unshallowed history for subsequent steps.
        run: |
          set -x

          git fetch --unshallow origin 2>/dev/null || true
          git fetch origin +refs/tags/*:refs/tags/*
          MESSAGE=$(git tag -l '${{ inputs.tag }}' --format='%(contents:subject)

          %(contents:body)
          ')
          export MESSAGE
          {
            echo "message<<EOF"
            printenv MESSAGE
            echo 'EOF'
          } >> "${GITHUB_OUTPUT}"

          echo "Message in git tag ${{ inputs.tag }}"
          echo "$MESSAGE"
      -
        name: Detect go mono-repo
        if: ${{ inputs.is-monorepo == 'true' }}
        id: detect-monorepo
        uses: go-openapi/gh-actions/ci-jobs/detect-go-monorepo@f94d1f200adab8d24b37584e5f61795a6062421d # v1.4.6
      -
        name: Install git-cliff [monorepo]
        if: ${{ inputs.is-monorepo == 'true' }}
        uses: taiki-e/install-action@288875dd3d64326724fa6d9593062d9f8ba0b131 # v2.67.30
        with:
          tool: git-cliff
      -
        name: Check for local cliff config
        id: check-config
        run: |
          if [[ -f '${{ inputs.cliff-config }}' ]]; then
            echo "exists=true" >> "${GITHUB_OUTPUT}"
            echo "::notice title=release::Local config file '${{ inputs.cliff-config }}' found"
          else
            echo "exists=false" >> "${GITHUB_OUTPUT}"
            echo "::notice title=release::Local config file '${{ inputs.cliff-config }}' not found, will use remote config"
          fi

          if [[ '${{ inputs.is-monorepo }}' == "true" && -f '${{ inputs.monorepo-cliff-template }}' ]]; then
            echo "monorepo-template-exists=true" >> "${GITHUB_OUTPUT}"
            echo "::notice title=release::Local monorepo config file '${{ inputs.monorepo-cliff-template }}' found"
          else
            echo "monorepo-template-exists=false" >> "${GITHUB_OUTPUT}"
            if [[ ${{ inputs.is-monorepo }} == "true" ]]; then
              echo "::notice title=release::Local monorepo config file '${{ inputs.monorepo-cliff-template }}' not found, will use remote config"
            else
              echo "::notice title=release::Local monorepo config file not needed"
            fi
          fi
      -
        name: Fetch remote cliff-monorepo template [monorepo]
        if: ${{ inputs.is-monorepo == 'true' && steps.check-config.outputs.monorepo-template-exists != 'true' }}
        env:
          MONOREPO_TEMPLATE_URL: ${{ inputs.monorepo-cliff-template-url }}
        run: |
          # Fetch the monorepo template from remote
          LOCAL_TEMPLATE_LOCATION="${RUNNER_TEMP:-/tmp}/.cliff-monorepo.toml"

          echo "::notice title=fetch-template::Fetching monorepo template from ${MONOREPO_TEMPLATE_URL}"
          curl -fsSL "${MONOREPO_TEMPLATE_URL}" -o "${LOCAL_TEMPLATE_LOCATION}"

          echo "::notice title=fetch-template::Monorepo template downloaded to ${LOCAL_TEMPLATE_LOCATION}"
      -
        name: Generate release notes [monorepo]
        if: ${{ inputs.is-monorepo == 'true' }}
        id: notes-monorepo
        env:
          RELEASE_TAG: ${{ inputs.tag }}
          TAG_MESSAGE: ${{ steps.get-message.outputs.message }}
          CLIFF_CONFIG: ${{ inputs.cliff-config }}
          CLIFF_CONFIG_URL: ${{ inputs.cliff-config-url }}
          CONFIG_EXISTS: ${{ steps.check-config.outputs.exists }}
          MONOREPO_TEMPLATE_EXISTS: ${{ steps.check-config.outputs.monorepo-template-exists }}
          GITHUB_REPO: ${{ github.repository }}
          GITHUB_TOKEN: ${{ github.token }}
          MODULE_RELATIVE_NAMES: ${{ steps.detect-monorepo.outputs.bash-relative-names }}
          MODULE_PATHS: ${{ steps.detect-monorepo.outputs.bash-paths }}
          ROOT_MODULE: ${{ steps.detect-monorepo.outputs.root-module }}
        run: |
          set -euo pipefail
          set -x

          LOCAL_TEMPLATE_LOCATION="${RUNNER_TEMP:-/tmp}/.cliff-monorepo.toml"
          ROOT_MODULE=$(echo "${ROOT_MODULE}"|sed -E 's/\/v[0-9]+$//')

          root_dir="$(git rev-parse --show-toplevel)"
          cd "${root_dir}"

          # Determine config path
          if [[ "${CONFIG_EXISTS}" == "true" ]] ; then
            cliff_config_flag="--config $(realpath "${CLIFF_CONFIG}")"
          else
            cliff_config_flag="--config-url ${CLIFF_CONFIG_URL}"
          fi
          
          # Determine monorepo template path
          if [[ "${MONOREPO_TEMPLATE_EXISTS}" == "true" ]] ; then
            cliff_monorepo=$(realpath "${{ inputs.monorepo-cliff-template }}")
          else
            cliff_monorepo="${LOCAL_TEMPLATE_LOCATION}"
          fi

          # Load monorepo template body
          body_monorepo_template=$(cat "${cliff_monorepo}")

          # Semver pattern for tag filtering
          semver_pattern="v\d+\.\d+\.\d+"

          # Build module arrays
          declare -a ALL_RELATIVE_MODULES
          mapfile -d' ' -t ALL_RELATIVE_MODULES < <(printf "%s" "${MODULE_RELATIVE_NAMES}")

          # Build absolute paths array
          declare -a ALL_FOLDERS
          mapfile -d' ' -t ALL_FOLDERS < <(printf "%s" "${MODULE_PATHS}")

          # Function to find child modules for exclusion (paths relative to repo root)
          function other_module_paths() {
            local current_index="$1"
            local current_module_path="$2"
            declare -a result

            for (( i=0; i<${#ALL_FOLDERS[@]}; i++ )); do
              [[ $i -le $current_index ]] && continue

              folder="${ALL_FOLDERS[$i]}"
              [[ "${folder}" == "${current_module_path}" ]] && continue

              # Check if folder is a child of current module
              if [[ "${folder}" =~ ^"${current_module_path}" ]] ; then
                relative_folder="${folder#${root_dir}/}"
                result+=("--exclude-path ${relative_folder}/**")
              fi
            done

            echo "${result[@]}"
          }

          # Create temp directory for module notes
          tmp_dir="${RUNNER_TEMP:-/tmp}/release-notes"
          rm -rf "${tmp_dir}"
          mkdir -p "${tmp_dir}"

          # Generate module-specific notes (Part 2)
          for (( i=0; i<${#ALL_RELATIVE_MODULES[@]}; i++ )); do
            folder="${ALL_FOLDERS[$i]}"

            # Derive relative folder path from repo root (filesystem-based, not module-name-based).
            # This avoids issues when GITHUB_REPO (fork) differs from the go module path (upstream).
            relative_folder="${folder#${root_dir}/}"
            if [[ "${relative_folder}" == "${folder}" || -z "${relative_folder}" ]] ; then
              # Root module is already covered by Part 1 (full changelog)
              echo "::notice title=module-notes::Skipping root module (covered by full changelog)"
              continue
            fi

            module_name="${relative_folder}"

            # Build exclusion list for child modules
            excluded=$(other_module_paths "${i}" "${folder}")

            # All modules use the root tag pattern for consistent version range resolution.
            # Non-root modules use --include-path to scope commits to their directory.
            # This avoids requiring per-module tags to exist for the previous release.
            tag_pattern="^${semver_pattern}$"
            include_path_flag="--include-path ${relative_folder}/**"

            echo "::notice title=module-notes::Generating notes for module: ${module_name}"

            # shellcheck disable=SC2086 # we want optional flags to expand
            # Disable glob expansion so --include-path and --exclude-path
            # glob patterns (e.g., codegen/**) are passed literally to git-cliff.
            set -f
            module_output=$(git-cliff \
                ${cliff_config_flag} \
                --body "${body_monorepo_template}" \
                --tag-pattern "${tag_pattern}" \
                --tag "${RELEASE_TAG}" \
                ${include_path_flag} \
                ${excluded} \
                --strip all \
                --latest \
                --with-tag-message "")
            set +f

            # Skip modules with no commits in this release
            if [[ -z "$(echo "${module_output}" | sed '/^[[:space:]]*$/d')" ]] ; then
              echo "::notice title=module-notes::Skipping module with no commits: ${module_name}"
              continue
            fi

            notes="${tmp_dir}/notes-$(echo "${module_name}" | tr '/' '-').md"

            {
              echo ""
              echo "---"
              echo ""
              echo "## ${module_name} (${RELEASE_TAG#v})"
              echo ""
              echo "${module_output}"
              echo ""
            } > "${notes}"
          done

          # Generate full changelog (Part 1)
          echo "::notice title=full-changelog::Generating full changelog with global sections"

          tag_pattern="^${semver_pattern}$"

          FULL_NOTES=$(git-cliff \
              ${cliff_config_flag} \
              --tag-pattern "${tag_pattern}" \
              --latest \
              --with-tag-message "${TAG_MESSAGE}")

          # Assemble final release notes (Part 1 + Part 2)
          {
            echo "${FULL_NOTES}"
            echo ""
            echo "# Per-module changes"
            echo ""
            cat "${tmp_dir}"/notes-*.md
          } > "${tmp_dir}/final-notes.md"

          # Save to output
          {
            echo "content<<EOF"
            cat "${tmp_dir}/final-notes.md"
            echo 'EOF'
          } >> "${GITHUB_OUTPUT}"

          # Log notes
          cat "${tmp_dir}/final-notes.md"

          # Cleanup
          rm -rf "${tmp_dir}"

          echo "::notice title=release-notes::Generated two-part release notes for mono-repo"
      -
        name: Generate release notes [local config]
        # this uses git-cliff to generate a release note from the commit history
        if: ${{ inputs.is-monorepo != 'true' && steps.check-config.outputs.exists == 'true' }}
        id: notes-local
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPO: ${{ github.repository }}
        uses: orhun/git-cliff-action@e16f179f0be49ecdfe63753837f20b9531642772 # v4.7.0
        with:
          config: ${{ inputs.cliff-config }}
          args: >-
            --latest
            --with-tag-message '${{ steps.get-message.outputs.message }}'
      -
        name: Generate release notes [remote config]
        # this uses git-cliff action with remote config URL
        if: ${{ inputs.is-monorepo != 'true' && steps.check-config.outputs.exists == 'false' }}
        id: notes-remote
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GITHUB_REPO: ${{ github.repository }}
        uses: orhun/git-cliff-action@e16f179f0be49ecdfe63753837f20b9531642772 # v4.7.0
        with:
          config: ''
          args: >-
            --config-url '${{ inputs.cliff-config-url }}'
            --latest
            --with-tag-message '${{ steps.get-message.outputs.message }}'
      -
        name: Create github release
        uses: softprops/action-gh-release@a06a81a03ee405af7f2048a818ed3f03bbf83c7b # v2.5.0
        with:
          body: ${{ inputs.is-monorepo == 'true' && steps.notes-monorepo.outputs.content || (steps.check-config.outputs.exists == 'true' && steps.notes-local.outputs.content || steps.notes-remote.outputs.content) }}
          tag_name: ${{ inputs.tag }}
          generate_release_notes: false # skip auto-generated release notes from github API
